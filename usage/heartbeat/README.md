# 长连接心跳机制实现

// todo
https://github.com/raylin0310/timewheel/blob/master/timewheel.go
https://github.com/raylin0310/timewheel/blob/master/timewheel_test.go
时间轮 http://xiaorui.cc/archives/6160
https://blog.csdn.net/xinzhongtianxia/article/details/86221241


## 前置知识
TCP 本身并没有长短连接的区别，长短与否，完全取决于我们怎么用它。
- 短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。
- 长连接：每次通信完毕后，不会关闭连接，这样就可以做到连接的复用。长连接的好处便是省去了创建连接的耗时。

短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，使用长连接，我们就需要担心各种问题：比如端对端连接的维护，连接的保活。

### tcp的keepalive机制
KeepAlive并不是TCP协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive开启后，在一定时间内（一般时间为 7200s，参数`tcp_keepalive_time`）在链路上没有数据传送的情况下，TCP层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试10（参数`tcp_keepalive_probes`）次，每次间隔时间75s（参数`tcp_keepalive_intvl`），所有探测失败后，才认为当前连接已经不可用。

KeepAlive在网络层面保证了连接的可用性，但在应用层还不够,主要体现在两个方面：
- KeepAlive的开关是在应用层开启的，但是具体参数（如重试测试，重试间隔时间）的设置却是操作系统级别的，位于操作系统的/etc/sysctl.conf配置中，这对于应用来说不够灵活。
- KeepAlive 的保活机制只在链路空闲的情况下才会起到作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是 ESTABLISHED，这时会发生什么？自然会走 TCP 重传机制，要知道默认的 TCP 超时重传，指数退避算法也是一个相当长的过程。
- KeepAlive 本身是面向网络的，并不是面向于应用的，当连接不可用时，可能是由于应用本身 GC 问题，系统 load 高等情况，但网络仍然是通的，此时，应用已经失去了活性，所以连接自然应该认为是不可用的。


## 聊聊实现细节
客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求（这里的请求是特殊的心跳请求），服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同框架对心跳，建连，断连，拉黑的机制有不同的策略;

具体的实现细节目前已知:
- 在应用层应该将心跳包与普通请求区分开来,如果将心跳请求识别为正常流量，会造成服务端的压力问题，干扰限流等诸多问题;
- 心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用则重连；服务端发现不可用则直接 close;
- 心跳检测不能一次不通就close, 应该设定一个超时总时间/响应失败总次数;
- 可以设计空闲检测,当client一定时间没有往server发消息时(空闲检测),再发送心跳包;在client频繁通信时不应该发送心跳包;实现思路是发送/接收到任何请求都更新心跳间隙时间;
- 设定ticker检测连接是否可用;
- 注意协程安全;

通常心跳包会设计为client向server持续发送心跳包;也有双向心跳的设计(如Dubbo);

### 心跳处理的另一个问题
通常一个连接就要开一个协程去处理心跳,当连接数几万几十万的时候,占用资源就比较多了;

另一种方法是只开启一个协程维护一个map,map里面保存了各个连接的最新心跳时间,该协程每秒遍历check一次map里过期的连接并close;这样的问题是
1. 每个连接在收到数据时都会对这个map进行lock和写操作,每次都会触发写锁;
2. 轮询map的性能并不好;


```go
go func() {
    for {
        select {
        case <-ctx.HeartBeatChan():
            continue
        case <-time.After(tcpx.HeatBeatInterval):
            times++
            if times == 3 {
                _ = ctx.CloseConn()
            }
            return
        }
    }
}()
```



## reference
- [聊聊 TCP 长连接和心跳那些事](http://blog.itpub.net/31556476/viewspace-2375225/)
- [如何设计一个优雅的心跳机制](http://blog.itpub.net/31556476/viewspace-2563653/)